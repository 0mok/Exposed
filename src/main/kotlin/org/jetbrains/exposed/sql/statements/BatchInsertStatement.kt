package org.jetbrains.exposed.sql.statements

import org.jetbrains.exposed.sql.Column
import org.jetbrains.exposed.sql.ColumnType
import org.jetbrains.exposed.sql.Table
import org.jetbrains.exposed.sql.Transaction
import org.jetbrains.exposed.sql.vendors.currentDialect
import java.sql.PreparedStatement
import java.util.ArrayList
import java.util.LinkedHashMap


class BatchInsertStatement(val table: Table, val _ignore: Boolean = false): Statement<List<Map<Column<*>, Any>>>(StatementType.INSERT, listOf(table)) {

    override val isAlwaysBatch = true

    val data = ArrayList<LinkedHashMap<Column<*>, Any?>>()

    fun addBatch() {
        data.add(LinkedHashMap())
        arguments = null
    }

    operator fun <T> set(column: Column<T>, value: T) {
        val values = data.last()

        if (values.containsKey(column)) {
            error("$column is already initialized")
        }

        values.put(column, column.columnType.valueToDB(value))
    }

    private var arguments: List<List<Pair<Column<*>, Any?>>>? = null
        get() {
            return field ?: data.map { single ->
                table.columns.filterNot { it.columnType.autoinc }.map {
                    it to (single[it] ?: it.defaultValueFun?.invoke() ?: it.dbDefaultValue)
                }
            }.apply { field = this }
        }

    override fun arguments(): Iterable<Iterable<Pair<ColumnType, Any?>>> {
        return arguments!!.map { it.map { it.first.columnType to it.second } }
    }

    override fun prepareSQL(transaction: Transaction): String {
        if (data.isNotEmpty()) {
            val columns = table.columns.filterNot { it.columnType.autoinc }

            val values = buildString {
                append("VALUES ")

                val firstCol = columns.first()
                val lastCol = columns.last()
                val lastIndex = columns.count() - 1

                columns.forEachIndexed { i, it ->
                    if (it == firstCol) append('(')
                    append('?')
                    if (i < lastIndex) append(',')
                    if (it == lastCol) append(')')
                }

            }

            return transaction.db.dialect.insert(_ignore, table, columns, values, transaction)
        }

        error("No data provided to insert")
    }

    override fun PreparedStatement.executeInternal(transaction: Transaction): List<Map<Column<*>, Any>> {
        if (data.isEmpty()) return emptyList()

        val result = executeBatch()
        val count = result.size

        assert(_ignore || count == data.size) { "Number of results don't match number of entries in batch" }

        val autoGeneratedKeys = arrayListOf<MutableMap<Column<*>, Any>>()

        val firstAutoIncColumn = table.columns.firstOrNull { it.columnType.autoinc }
        if (firstAutoIncColumn != null) {
            val rs = generatedKeys!!
            while (rs.next()) {
                autoGeneratedKeys.add(hashMapOf(firstAutoIncColumn to rs.getObject(1)))
            }

            if (count > 1 && !currentDialect.supportsMultipleGeneratedKeys) {
                // H2/SQLite only returns one last generated key...
                (autoGeneratedKeys[0][firstAutoIncColumn] as? Number)?.toLong()?.let {
                    var id = it

                    while (autoGeneratedKeys.size < count) {
                        id -= 1
                        autoGeneratedKeys.add(0, hashMapOf(firstAutoIncColumn to id))
                    }
                }
            }

            assert(_ignore || autoGeneratedKeys.isEmpty() || autoGeneratedKeys.size == count) {
                "Number of autoincs (${autoGeneratedKeys.size}) doesn't match number of batch entries ($count)"
            }
        }
        arguments!!.forEachIndexed { i, pairs ->
            pairs.forEach { pair ->
                val itemIndx = i
                val (col, value) = pair
                if (!col.columnType.autoinc) {
                    val map = autoGeneratedKeys.getOrElse(itemIndx) {
                        hashMapOf<Column<*>, Any>().apply {
                            autoGeneratedKeys.add(itemIndx, this)
                        }
                    }
                    if (col.defaultValueFun != null && value != null && data[itemIndx][col] == null) {
                        map[col] = value
                    }
                }
            }
        }
        return autoGeneratedKeys
    }

}
