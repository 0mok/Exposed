package org.jetbrains.exposed.sql.statements

import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.transactions.TransactionManager
import org.jetbrains.exposed.sql.vendors.currentDialect
import java.sql.PreparedStatement
import java.sql.ResultSet
import java.util.*

internal class BatchDataInconsistent(message : String) : Exception(message)

open class BatchInsertStatement(table: Table, ignore: Boolean = false): InsertStatement<List<Map<Column<*>, Any>>>(table, ignore) {

    override val flushCache: Boolean = false

    override val isAlwaysBatch = true

    val data = ArrayList<MutableMap<Column<*>, Any?>>()

    private fun Column<*>.isDefaultable() = columnType.nullable || defaultValueFun != null

    override operator fun <S> set(column: Column<S>, value: S?) {
        if (data.size > 1 && column !in data[data.size - 2] && !column.isDefaultable()) {
            throw BatchDataInconsistent("Can't set $value for ${TransactionManager.current().fullIdentity(column)} because previous insertion can't be defaulted for that column.")
        }
        super.set(column, value)
    }

    fun addBatch() {
        if (data.isNotEmpty()) {
            validateLastBatch()
            data[data.size - 1] = LinkedHashMap(values)
            values.clear()
        }
        data.add(values)
        arguments = null
    }

    internal open fun validateLastBatch() {
        val cantBeDefaulted = (data.last().keys - values.keys).filterNot { it.isDefaultable() }
        if (cantBeDefaulted.isNotEmpty()) {
            val columnList = cantBeDefaulted.joinToString { TransactionManager.current().fullIdentity(it) }
            throw BatchDataInconsistent("Can't add new batch because columns: $columnList don't have client default values. DB defaults don't support in batch inserts")
        }
        val requiredInTargets = (targets.flatMap { it.columns } - values.keys).filter { !it.isDefaultable() && !it.columnType.isAutoInc }
        if (requiredInTargets.any()) {
            throw BatchDataInconsistent("Can't add new batch because columns: ${requiredInTargets.joinToString()} don't have client default values. DB defaults don't support in batch inserts")
        }
    }

    private fun allColumnsInDataSet() = data.fold(setOf<Column<*>>()) { columns, row ->
        columns + row.keys
    }

    protected var arguments: List<List<Pair<Column<*>, Any?>>>? = null
        get() = field ?: run {
            val nullableColumns = allColumnsInDataSet().filter { it.columnType.nullable }
            data.map { single ->
                val valuesAndDefaults = super.valuesAndDefaults(single)
                (valuesAndDefaults + (nullableColumns - valuesAndDefaults.keys).associate { it to null }).toList().sortedBy { it.first }
            }.apply { field = this }
        }

    override fun valuesAndDefaults(values: Map<Column<*>, Any?>) = arguments!!.first().toMap()

    override fun arguments() = arguments!!.map { it.map { it.first.columnType to it.second }.filter { it.second != DefaultValueMarker} }

    override fun generatedKeyFun(rs: ResultSet?, inserted: Int): List<Map<Column<*>, Any>>? {
        val autoGeneratedKeys = arrayListOf<MutableMap<Column<*>, Any>>()

        val firstAutoIncColumn = autoIncColumns.firstOrNull()
        if (firstAutoIncColumn != null) {
            while (rs?.next() == true) {
                autoGeneratedKeys.add(hashMapOf(firstAutoIncColumn to rs.getObject(1)))
            }

            if (inserted > 1 && !currentDialect.supportsMultipleGeneratedKeys) {
                // H2/SQLite only returns one last generated key...
                (autoGeneratedKeys[0][firstAutoIncColumn] as? Number)?.toLong()?.let {
                    var id = it

                    while (autoGeneratedKeys.size < inserted) {
                        id -= 1
                        autoGeneratedKeys.add(0, hashMapOf(firstAutoIncColumn to id))
                    }
                }
            }

            /** FIXME: https://github.com/JetBrains/Exposed/issues/129
             *  doesn't work with MySQL `INSERT ... ON DUPLICATE UPDATE`
             */
//            assert(isIgnore || autoGeneratedKeys.isEmpty() || autoGeneratedKeys.size == inserted) {
//                "Number of autoincs (${autoGeneratedKeys.size}) doesn't match number of batch entries ($inserted)"
//            }
        }
        // REVIEW
        arguments!!.forEachIndexed { itemIndx, pairs ->
            pairs.forEach { (col, value) ->
                if (!col.columnType.isAutoInc) {
                    val map = autoGeneratedKeys.getOrElse(itemIndx) {
                        hashMapOf<Column<*>, Any>().apply {
                            autoGeneratedKeys.add(itemIndx, this)
                        }
                    }
                    if (col.defaultValueFun != null && value != null && data[itemIndx][col] == null) {
                        map[col] = value
                    }
                }
            }
        }
        return autoGeneratedKeys
    }
}

class SQLServerBatchInsertStatement(table: Table, ignore: Boolean = false) : BatchInsertStatement(table, ignore) {
    override val isAlwaysBatch: Boolean = false
    private val OUTPUT_ROW_LIMIT = 1000
    private val OUTPUT_PARAMS_LIMIT = 5000

    override fun validateLastBatch() {
        super.validateLastBatch()
        if (data.size > OUTPUT_ROW_LIMIT) {
            throw BatchDataInconsistent("Too much rows in one batch. Exceed $OUTPUT_ROW_LIMIT limit")
        }
        val paramsToInsert = data.firstOrNull()?.size ?: 0
        if (paramsToInsert * (data.size + 1) > OUTPUT_PARAMS_LIMIT) {
            throw BatchDataInconsistent("Too much parameters for batch with OUTPUT. Exceed $OUTPUT_PARAMS_LIMIT limit")
        }
    }

    override fun prepareSQL(transaction: Transaction): String {
        val values = arguments!!
        val sql = if (values.isEmpty()) ""
        else {
            val builder = QueryBuilder(true)
            val output = table.autoIncColumn?.let { " OUTPUT inserted.${transaction.identity(it)} AS GENERATED_KEYS" }.orEmpty()
            values.joinToString(prefix = "$output VALUES") {
                it.joinToString(prefix = "(", postfix = ")") { (col, value) ->
                    builder.registerArgument(col, value)
                }
            }
        }
        return transaction.db.dialect.insert(isIgnore, table, values.firstOrNull()?.map { it.first }.orEmpty(), sql, transaction)
    }

    override fun arguments() = listOf(super.arguments().flatten())

    override fun PreparedStatement.executeInternal(transaction: Transaction): Int {
        transaction.entityCache.removeTablesReferrers(listOf(table))
        generatedKey = generatedKeyFun(executeQuery(), arguments!!.size)
        return arguments!!.size
    }
}
